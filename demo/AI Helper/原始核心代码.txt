原始学生类定义 student.py
```
class Student:
    def __init__(self, sId, communities, completed_courses, wish_courses, MAX_WISH_COURSES=5):
        """
        构造学生类。

        :param sId: int, 学生的唯一标识符
        :param communities: set, 学生当前参与的学习共同体集合
        :param completed_courses: list, 学生已经完成的课程列表，课程信息包括课程id和对应成绩
        :param wish_courses: list, 学生希望学习的课程id列表
        :param MAX_WISH_COURSES: int, 学生愿望课程列表的最大长度，默认为5
        """
        self.sId = sId
        self.communities = communities
        self.completed_courses = completed_courses
        self.wish_courses = wish_courses[:MAX_WISH_COURSES]  # 在初始化时就确保不超过最大愿望课程数量
        self.wish_course = None if not wish_courses else wish_courses[0]  # 初始化时设定的愿望课程
        self.MAX_WISH_COURSES = MAX_WISH_COURSES

    def add_completed_course(self, course_id, score):
        """
        向学生的已修课程列表中添加新课程。

        :param course_id: int, 要添加的新课程的id
        :param score: int, 学生在该课程中获得的成绩
        """
        # 检查课程是否已存在于已修课程列表中
        for course in self.completed_courses:
            if course['id'] == course_id:
                # 如果课程已存在，可以选择更新成绩，或者直接返回
                course['score'] = score
                return
        # 如果课程不存在，则添加到列表中
        self.completed_courses.append({'id': course_id, 'score': score})

    def remove_completed_course(self, course_id):
        """
        从学生的已修课程列表中移除课程。

        :param course_id: int, 要移除的课程的id
        """
        self.completed_courses = [course for course in self.completed_courses if course['id'] != course_id]

    def update_wish_course(self, course_id):
        """
        更新学生的当前愿望课程，并在必要时更新愿望课程列表。

        :param course_id: int, 学生希望学习的新课程的id
        """
        self.wish_course = course_id  # 设置当前的愿望课程
        if course_id not in self.wish_courses:
            # 如果愿望课程列表满了，则移除最早添加的课程，使用pop(0)
            if len(self.wish_courses) >= self.MAX_WISH_COURSES:
                self.wish_courses.pop(0)
            self.wish_courses.append(course_id)  # 添加新的愿望课程到列表

    def join_community(self, community):
        """
        学生加入学习共同体。

        :param community: StudyCommunity, 学生希望加入的学习共同体对象
        :return: bool, 学生是否成功加入共同体
        """
        if community.join_member(self):
            self.communities.add(community)
            return True
        else:
            return False

    def quit_community(self, community):
        """
        学生退出学习共同体。

        :param community: StudyCommunity, 学生希望退出的学习共同体对象
        :return: bool, 学生是否成功退出共同体
        """
        if community in self.communities and community.remove_member(self.sId):
            self.communities.remove(community)
            return True
        else:
            return False

```

------
原始学习共同体类定义  StudyCommunity.py
```
class StudyCommunity:
    def __init__(self, comId, member_ids, completed_courses, wish_courses,
                 calculate_course_similarity, calculate_member_similarity,
                 MAX_MEMBERS=8, MAX_WISH_COURSES=5):
        """
        构造学习共同体类。

        :param comId: int, 共同体的唯一标识符
        :param member_ids: list, 成员的id列表
        :param completed_courses: list, 包含成员已完成课程id和成绩的列表
        :param wish_courses: list, 包含成员想学的课程id列表（0-MAX_WISH_COURSES个）
        :param calculate_course_similarity: function, 计算课程相似度的函数
        :param calculate_member_similarity: function, 计算成员相似度的函数
        :param MAX_MEMBERS: int, 共同体最大成员数
        :param MAX_WISH_COURSES: int, 最大愿望课程列表长度
        """
        self.comId = comId
        self.member_ids = member_ids
        self.completed_courses = completed_courses
        self.wish_courses = wish_courses
        self.calculate_course_similarity = calculate_course_similarity
        self.calculate_member_similarity = calculate_member_similarity
        self.MAX_MEMBERS = MAX_MEMBERS
        self.MAX_WISH_COURSES = MAX_WISH_COURSES
        self.member_count = len(member_ids)

    def join_member(self, new_member_id, new_member_completed_courses, new_member_wish_courses):
        """
        学生选择加入共同体，并按照规则更新共同体的已修课程和愿望课程列表。

        :param new_member_id: int, 新成员的id
        :param new_member_completed_courses: list, 新成员已修课程列表
        :param new_member_wish_courses: list, 新成员的愿望课程列表
        :return: bool, 新成员是否成功加入
        """
        if self.member_count >= self.MAX_MEMBERS or new_member_id in self.member_ids:
            return False  # 超过最大成员数或已在其中，加入失败

        # Set operation for updating completed_courses and wish_courses
        completed_courses_set = set([course['id'] for course in self.completed_courses])
        wish_courses_set = set(self.wish_courses)
        new_member_completed_courses_set = set([course['id'] for course in new_member_completed_courses])
        new_member_wish_courses_set = set(new_member_wish_courses)

        # Update the wish_courses by removing courses already known by the new member
        # and adding new wish courses from the new member
        # that were not known by the community before.
        updated_wish_courses = list((wish_courses_set - new_member_completed_courses_set) |
                                    (new_member_wish_courses_set - completed_courses_set))

        # Apply the max wish courses constraint
        self.wish_courses = updated_wish_courses[:self.MAX_WISH_COURSES]

        # Update the completed_courses by union with the new member's completed_courses
        self.completed_courses += [course for course in new_member_completed_courses
                                   if course['id'] not in completed_courses_set]

        # Add the new member
        self.member_ids.append(new_member_id)
        self.member_count += 1

        return True  # 成员成功加入

    def remove_member(self, member_id):
        """
        从共同体中移除一个学生成员，并更新团队已修课程列表。

        :param member_id: int, 要移除的成员的id
        :return: bool, 成员是否成功被移除
        """
        if member_id not in self.member_ids:
            return False  # 如果成员不在共同体中，移除失败

        # 首先，找出需要被移除的成员的已修课程列表
        member_courses_to_remove = [course for course in self.completed_courses if course['member_id'] == member_id]

        # 从共同体的成员ID列表中移除该成员
        self.member_ids.remove(member_id)
        self.member_count -= 1

        # 更新共同体的已学课程列表
        # 只保留那些不是被移除的学生独有的已修课程
        member_courses_to_remove_ids = set([course['id'] for course in member_courses_to_remove])
        self.completed_courses = [
            course for course in self.completed_courses
            if course['id'] not in member_courses_to_remove_ids or course['member_id'] != member_id
        ]

        return True  # 成员成功被移除

    def is_member_in_community(self, student_id):
        """
        判断指定学生是否属于这个共同体。

        :param student_id: int, 学生的ID
        :return: bool, 指定学生是否是共同体的成员
        """
        return student_id in self.member_ids

    def evaluate_member_similarity(self, student):
        """
        基于学生的愿望课程及已完成课程与共同体完成的课程和愿望课程列表相匹配的程度，计算学生与共同体的相似度。

        :param student: Student, 学生对象
        :return: float, 学生对象与共同体的相似度评分
        """
        # 计算学生愿望课程与共同体已完成课程的相似度评分
        wish_course_similarity = 0
        if student.wish_course and self.completed_courses:
            for completed_course in self.completed_courses:
                wish_course_similarity += self.calculate_course_similarity(student.wish_course, completed_course['id'])
            wish_course_similarity /= len(self.completed_courses)

        # 计算学生已完成课程与共同体愿望课程列表的相似度评分
        completed_course_similarity = 0
        if student.completed_courses and self.wish_courses:
            for student_completed_course in student.completed_courses:
                for wish_course_id in self.wish_courses:
                    completed_course_similarity += self.calculate_course_similarity(student_completed_course['id'],
                                                                                    wish_course_id)
            completed_course_similarity /= (len(student.completed_courses) * len(self.wish_courses))

        # 最终相似度评分是两部分匹配度的加权平均
        final_similarity_score = 0.5 * wish_course_similarity + 0.5 * completed_course_similarity

        return final_similarity_score

    def calculate_avg_course_similarity(self):
        """
        计算学习共同体中所有已修课程之间的平均相似度。

        :return: float, 所有课程对之间相似度的平均值
        """
        # 确保共同体中有足够的课程进行相似度计算，至少需要2门不同课程
        if len(self.completed_courses) < 2:
            return 0.0  # 如果不足两门课程，则返回0

        # 初始化相似度总和和比较次数
        similarity_sum = 0
        comparisons = 0

        # 对共同体中已修课程两两之间进行相似度计算
        for i in range(len(self.completed_courses) - 1):
            for j in range(i + 1, len(self.completed_courses)):
                # 使用提供的课程相似度计算函数计算两门课程之间的相似度
                similarity = self.calculate_course_similarity(self.completed_courses[i], self.completed_courses[j])
                similarity_sum += similarity
                comparisons += 1

        # 计算平均相似度
        if comparisons == 0:  # 如果不存在可比较的课程对，返回0
            return 0.0
        else:
            return similarity_sum / comparisons

    def calculate_avg_member_similarity(self):
        """
        计算学习共同体中所有成员之间的平均相似度。

        :return: float, 所有成员对之间相似度的平均值
        """
        # 确保共同体中有足够的成员进行相似度计算，至少需要2个成员
        if len(self.member_ids) < 2:
            return 0.0  # 如果不足两个成员，则返回0

        # 初始化相似度总和和比较次数
        similarity_sum = 0
        comparisons = 0

        # 对共同体中成员两两之间进行相似度计算
        for i in range(len(self.member_ids) - 1):
            for j in range(i + 1, len(self.member_ids)):
                # 使用提供的成员相似度计算函数计算两个成员之间的相似度
                similarity = self.calculate_member_similarity(self.member_ids[i], self.member_ids[j])
                similarity_sum += similarity
                comparisons += 1

        # 计算平均相似度
        if comparisons == 0:  # 如果不存在可比较的成员对，返回0
            return 0.0
        else:
            return similarity_sum / comparisons

```

------
原始主要业务逻辑 demo.py
```
from Student import Student
from StudyCommunity import StudyCommunity
import pandas as pd
import numpy as np


# 更新的课程相似度计算函数
def calculate_course_similarity(course_a_id, course_b_id):
    # 加载相似度矩阵及索引关系
    course_id_to_index = {id_: index for index, id_ in enumerate(unique_courses)}

    # 通过原始ID获取索引
    course_a_index = course_id_to_index.get(course_a_id)
    course_b_index = course_id_to_index.get(course_b_id)

    # 检查两个课程ID是否都在映射字典中
    if course_a_index is not None and course_b_index is not None:
        # 使用索引获取相似度矩阵中的值
        return course_similarity_matrix[course_a_index, course_b_index]
    else:
        # 如果课程ID不在映射字典中，抛出异常提示
        raise ValueError(f"至少一个课程ID未找到: {course_a_id} 或 {course_b_id}")


def calculate_member_similarity(member_a_id, member_b_id):
    # 加载相似度矩阵及索引关系
    user_id_to_index = {id_: index for index, id_ in enumerate(unique_users)}

    # 通过原始ID获取索引
    member_a_index = user_id_to_index.get(member_a_id)
    member_b_index = user_id_to_index.get(member_b_id)

    # 检查两个用户ID是否都在映射字典中
    if member_a_index is not None and member_b_index is not None:
        # 使用索引获取相似度矩阵中的值
        return student_similarity_matrix[member_a_index, member_b_index]
    else:
        # 如果用户ID不在映射字典中，抛出异常提示
        raise ValueError(f"至少一个用户ID未找到: {member_a_id} 或 {member_b_id}")


def init(scores_df):
    students = {}
    communities = {}

    # 用于记录用户和其对应的共同体id
    student_to_community = {}

    # 用于为共同体分配独立的索引值
    next_community_id = 0

    scores_df['userId'] = scores_df['userId'].astype(int)
    scores_df['courseId'] = scores_df['courseId'].astype(int)

    for index, row in scores_df.iterrows():
        user_id = int(row['userId'])
        course_id = int(row['courseId'])
        score = row['score']

        # 创建或更新学生对象
        if user_id not in students:
            # 初始化学生对象
            students[user_id] = Student(sId=user_id,
                                        communities=set(),
                                        completed_courses=[{'id': course_id, 'score': score}],
                                        wish_courses=[],
                                        MAX_WISH_COURSES=5)

            # 初始化对应的共同体对象
            communities[next_community_id] = StudyCommunity(comId=next_community_id,
                                                            member_ids=[user_id],
                                                            completed_courses=[{'id': course_id, 'score': score}],
                                                            wish_courses=[],
                                                            calculate_course_similarity=calculate_course_similarity,
                                                            calculate_member_similarity=calculate_member_similarity,
                                                            MAX_MEMBERS=8,
                                                            MAX_WISH_COURSES=5)
            student_to_community[user_id] = next_community_id
            next_community_id += 1
        else:
            # 学生已存在，添加完成的课程
            students[user_id].add_completed_course(course_id, score)

            # 获取学生对应的共同体id，并更新该共同体的已完成的课程列表
            community_id = student_to_community[user_id]
            communities[community_id].completed_courses.append({'id': course_id, 'score': score})

    return students, communities


def recommend(student, wish_course, count=10):
    if wish_course in student.completed_courses:
        return False
    student.update_wish_course(wish_course)

    recommend_communities = []
    for community in communities.values():
        if community.member_count >= community.MAX_MEMBERS or community.is_member_in_community(student.sId):
            continue
        sim = community.evaluate_member_similarity(student)
        recommend_communities.append([sim, community])
    recommend_communities = sorted(recommend_communities, key=lambda x: x[0], reverse=True)
    return recommend_communities[:count]


def student_join_community(student, community):
    if community.member_count >= community.MAX_MEMBERS or community.is_member_in_community(student.sId):
        return False
    return student.join_community(community)


def study_quit_community(student, community):
    if not community.is_member_in_community(student.sId):
        return False
    return student.quit_community(community)


if __name__ == '__main__':
    # 读取CSV文件
    path = "D:/毕业设计/数据/DatasetOneResult/"
    scores_df = pd.read_csv(f'{path}scores.csv')

    unique_courses = np.load('../学生_课程矩阵分解/course_ids_index_mapping.npy')
    course_similarity_matrix = np.load('../学生_课程矩阵分解/course_similarity.npy')
    unique_users = np.load('../学生_课程矩阵分解/user_ids_index_mapping.npy')
    student_similarity_matrix = np.load('../学生_课程矩阵分解/student_similarity.npy')

    students, communities = init(scores_df)

    recommend_communities = recommend(students[3], 599)
    print(recommend_communities)
```

------
原始业务逻辑中相似度矩阵的机器学习过程 MatrixFac.py：
```
import torch
import numpy as np
import pandas as pd
from torch.autograd import Variable
import torch.nn.functional as F


class MatrixFactorization(torch.nn.Module):
    def __init__(self, n_users, n_items, n_factors=20):
        super(MatrixFactorization, self).__init__()
        self.user_factors = torch.nn.Embedding(n_users, n_factors, sparse=True)
        self.item_factors = torch.nn.Embedding(n_items, n_factors, sparse=True)

    def forward(self, user, item):
        return (self.user_factors(user) * self.item_factors(item)).sum(1)

    def predict(self, user, item):
        return self.forward(user, item)


# 添加函数以计算余弦相似度
def compute_cosine_similarity(matrix):
    # Normalize the matrix to compute cosine similarity
    norm_matrix = F.normalize(matrix)
    similarity = torch.mm(norm_matrix, norm_matrix.t())
    return similarity


if __name__ == '__main__':
    # 读取数据
    path = "D:/毕业设计/数据/DatasetOneResult/"
    df = pd.read_csv(f'{path}scores.csv')

    # 将userId和courseId映射到索引
    df['userId'], unique_users = pd.factorize(df['userId'])
    df['courseId'], unique_courses = pd.factorize(df['courseId'])

    # 计算用户数和课程数
    num_users = len(unique_users)
    num_courses = len(unique_courses)

    # 创建模型
    num_factors = 64  # 这里选择隐因子数量为64，可根据实际情况调整
    model = MatrixFactorization(num_users, num_courses, n_factors=num_factors)

    # 损失函数和优化器
    loss_fn = torch.nn.MSELoss()  # 均方误差损失
    optimizer = torch.optim.SparseAdam(model.parameters(), lr=1e-1)

    # 训练模型
    num_epochs = 10
    for epoch in range(num_epochs):
        for row in df.itertuples():
            user = Variable(torch.LongTensor([row.userId]))
            item = Variable(torch.LongTensor([row.courseId]))
            score = Variable(torch.FloatTensor([row.score]))

            # 预测
            prediction = model.predict(user, item)
            loss = loss_fn(prediction, score)

            # 反向传播
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

        print(f'Epoch {epoch + 1}/{num_epochs} - Loss: {loss.data}')

    # 计算并保存学生相似度和课程相似度矩阵
    student_similarity = compute_cosine_similarity(model.user_factors.weight.data)
    course_similarity = compute_cosine_similarity(model.item_factors.weight.data)

    # 将相似度矩阵转换为NumPy数组并保存
    np.save('student_similarity.npy', student_similarity.numpy())
    np.save('course_similarity.npy', course_similarity.numpy())

    # 保存用户和课程的原始ID与新索引之间的映射关系
    # 正确保存 pd.factorize() 返回的唯一值数组，它们包含原始ID到新索引的映射
    np.save('user_ids_index_mapping.npy', unique_users)
    np.save('course_ids_index_mapping.npy', unique_courses)

    print('学生相似度和课程相似度矩阵以及映射关系已经保存。')
```
